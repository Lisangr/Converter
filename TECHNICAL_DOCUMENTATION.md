# Техническая документация: Converter

## 1. Архитектура

Проект реализован на основе современной многоуровневой архитектуры, следующей принципам **Domain-Driven Design (DDD)** и паттерну **Model-View-Presenter (MVP)**. Архитектура обеспечивает четкое разделение ответственности между слоями, делая систему более гибкой, тестируемой и простой в сопровождении.

### 1.1. Domain Layer (`src/Converter.Domain`)

**Назначение**: Ядро приложения, содержащее бизнес-логику и модели предметной области.

**Основные компоненты**:
- **`Models/`**: Бизнес-модели и сущности
  - `QueueItem` - элемент очереди конвертации со статусом, прогрессом и настройками
  - `ConversionSettings` - настройки конвертации (кодеки, битрейты, параметры)
  - `AudioProcessingOptions` - опции обработки аудио
  - `AppSettings`, `UserPreferences` - настройки приложения
- **Перечисления**: `ConversionStatus` (Pending, Processing, Completed, Failed, Paused, Cancelled)

**Принципы**: Полная независимость от других слоев, отсутствие внешних зависимостей.

### 1.2. Application Layer (`src/Converter.Application`)

**Назначение**: Содержит логику приложения, координацию между слоями и определение контрактов.

**Основные компоненты**:

#### Abstractions
- **`IQueueService`**: Управление очередью конвертации
- **`IConversionOrchestrator`**: Оркестрация процесса конвертации
- **`IFFmpegExecutor`**: Выполнение команд FFmpeg
- **`IQueueRepository`**: Доступ к данным очереди
- **`IProfileProvider`**: Управление профилями/пресетами
- **`IProgressReporter`**: Отчетность о прогрессе
- **`IMainView`**: Контракт главного представления

#### Presenters
- **`MainPresenter`**: Центральный презентер, координирующий взаимодействие между View и остальными слоями
  - Обрабатывает события UI (добавление файлов, запуск конвертации)
  - Управляет очередью через `IQueueService`
  - Обновляет UI через `IMainView`
  - Реализует паттерн Observer для отслеживания изменений

#### Services
- **`QueueService`**: Управление очередью с поддержкой параллельной обработки
- **`ConversionOrchestrator`**: Координация процесса конвертации
- **`ProfileProvider`**: Работа с профилями и пресетами
- **`OutputPathBuilder`**: Построение путей выходных файлов

#### ViewModels
- **`QueueItemViewModel`**: ViewModel для элементов очереди
- **`MainViewModel`**: Главная ViewModel
- **`BindingListAdapter`**: Адаптер для привязки данных

#### DTOs
- **`QueueItemDto`**: Data Transfer Object для передачи данных между слоями

### 1.3. Infrastructure Layer (`src/Converter.Infrastructure`)

**Назначение**: Реализация интерфейсов, определенных в Application layer, работа с внешними системами.

**Основные компоненты**:

#### Ffmpeg
- **`FFmpegExecutor`**: Выполнение команд FFmpeg с поддержкой отмены и прогресса
- **`ThumbnailProvider`**: Генерация превью видео
- **`FfmpegBootstrapService`**: Автоматическая установка FFmpeg

#### Persistence
- **`JsonQueueStore`**: Сохранение очереди в JSON
- **`JsonSettingsStore`**: Сохранение настроек в JSON
- **`FileSettingsStore`**: Работа с файлами настроек
- **`JsonPresetRepository`**: Работа с пресетами в формате JSON

#### Notifications
- **`NotificationGateway`**: Система уведомлений

#### Service Collection Extensions
- **`ServiceCollectionExtensions`**: Настройка Dependency Injection

### 1.4. Presentation Layer

**Основные компоненты**:
- **`Form1.cs`**: Реализует `IMainView`, выступает как View в MVP паттерне
- **`UI/`**: Переиспользуемые контролы, диалоги и панели
- **Устаревшие компоненты**: `Services/`, `Models/` - в процессе миграции в новую архитектуру

### 1.4. Паттерн Model-View-Presenter (MVP)

Архитектура проекта следует паттерну MVP для четкого разделения ответственности:

1.  **View (`Form1` → `IMainView`)**: 
   - Отвечает только за отображение данных и перехват действий пользователя
   - Не содержит бизнес-логики
   - При возникновении события (клик, drag&drop) вызывает соответствующий метод презентера через события интерфейса
   - Обновляется через методы `IMainView` (показ прогресса, уведомления, изменение состояния)

2.  **Presenter (`MainPresenter`)**:
   - Получает события от View через подписку на интерфейс `IMainView`
   - Обрабатывает пользовательские действия и взаимодействует с сервисами Application layer
   - Управляет состоянием через `MainViewModel` и `QueueItemViewModel`
   - Координирует работу `IQueueService`, `IConversionOrchestrator`, `IFFmpegExecutor`
   - Обновляет View через методы `IMainView`

3.  **Model (`Converter.Domain`)**:
   - Представляет данные и бизнес-логику приложения
   - Независим от Presentation и Infrastructure слоев
   - Содержит сущности предметной области (`QueueItem`, `ConversionSettings`)

## 2. Поток выполнения конвертации

### 2.1. Добавление файлов в очередь

1. **Инициация**: Пользователь добавляет файлы через UI (`DragDropPanel` или диалог выбора файлов)
2. **Событие View**: `Form1` (реализующая `IMainView`) генерирует событие `AddFilesRequested` или `FilesDropped`
3. **Обработка в Presenter**: `MainPresenter` получает событие и:
   - Проверяет существование файлов
   - Создает объекты `QueueItem` с начальным статусом `Pending`
   - Добавляет их в очередь через `IQueueRepository`
   - Обновляет ViewModel и UI

### 2.2. Запуск процесса конвертации

1. **Инициация**: Пользователь нажимает кнопку "Start Conversion"
2. **Событие View**: `Form1` генерирует событие `StartConversionRequested`
3. **Обработка в Presenter**: `MainPresenter`:
   - Вызывает `IQueueProcessor.StartProcessingAsync()`
   - Передает токен отмены для корректной остановки

### 2.3. Выполнение конвертации

1. **QueueService**: `QueueService` (реализация `IQueueService`):
   - Извлекает следующий элемент из очереди (по приоритету и времени добавления)
   - Меняет статус на `Processing`
   - Генерирует событие `ItemChanged`

2. **ConversionOrchestrator**: Координирует процесс:
   - Использует `IFFmpegExecutor` для выполнения команд FFmpeg
   - Отслеживает прогресс через `IProgressReporter`
   - Управляет жизненным циклом процесса

3. **FFmpegExecutor**: В `Converter.Infrastructure`:
   - Выполняет команду FFmpeg в отдельном процессе
   - Отслеживает вывод и ошибки
   - Поддерживает отмену через `CancellationToken`
   - Предоставляет прогресс через `IProgress<double>`

### 2.4. Обновление состояния и UI

1. **События QueueService**: При изменении статуса элемента генерируется событие `ItemChanged`
2. **Обновление в Presenter**: `MainPresenter`:
   - Подписан на события `IQueueRepository` и `IQueueProcessor`
   - Обновляет соответствующие `QueueItemViewModel`
   - Вызывает методы `IMainView` для обновления UI

3. **Обновление View**: `Form1`:
   - Отображает прогресс в реальном времени
   - Показывает статус обработки
   - Уведомляет пользователя о завершении или ошибках

### 2.5. Завершение процесса

1. **Успешное завершение**: Элемент получает статус `Completed`, прогресс 100%
2. **Ошибка**: Элемент получает статус `Failed` с описанием ошибки
3. **Завершение очереди**: `QueueProcessor` генерирует событие `QueueCompleted`
4. **Финализация**: `MainPresenter` обновляет UI и показывает итоговую статистику

## 3. Компоненты UI (директория `UI/`)

Директория `UI/` содержит переиспользуемые элементы управления, диалоги и панели, которые инкапсулируют определенную часть функциональности интерфейса. Подробное описание компонентов находится в файле `UI/README.md`.

## 4. Расширение функциональности

### 4.1. Добавление новых пресетов

**Механизм**: Пресеты управляются через `IProfileProvider` и `IPresetRepository`

**Шаги**:
1. **Domain Layer**: Добавить новые свойства в `ConversionSettings` при необходимости
2. **Infrastructure**: Реализовать загрузку в `JsonPresetRepository` или `XmlPresetLoader`
3. **UI**: Создать элементы управления для настройки новых параметров
4. **Application**: Обновить `ConversionCommandBuilder` для использования новых настроек

### 4.2. Добавление новых опций кодирования

**Механизм**: Расширение настроек через Domain модели

**Шаги**:
1. **Domain Layer**: Расширить `ConversionSettings` новыми свойствами
2. **Application**: Создать соответствующие интерфейсы и сервисы
3. **Infrastructure**: Реализовать обработку в `FFmpegExecutor`
4. **UI**: Добавить элементы управления в соответствующие панели

### 4.3. Поддержка других платформ UI

**Механизм**: Замена только Presentation layer благодаря четкой архитектуре

**Примеры**:
- **WPF**: Реализовать `IMainView` для WPF, использовать существующие `MainPresenter` и слои Domain/Application/Infrastructure
- **MAUI**: Аналогично - новый View слой с сохранением всей бизнес-логики
- **Web**: Создать ASP.NET Core API на основе существующих Application/Infrastructure сервисов

### 4.4. Добавление новых источников данных

**Механизм**: Расширение через Repository pattern

**Примеры**:
- **База данных**: Создать `DatabaseQueueStore` реализующий `IQueueRepository`
- **Облачное хранилище**: Реализовать `CloudQueueStore` для работы с облачными сервисами
- **Сетевые источники**: Добавить поддержку URL-адресов в качестве источников

### 4.5. Интеграция с внешними сервисами

**Механизм**: Расширение Infrastructure layer

**Примеры**:
- **Облачные кодировщики**: Создать сервисы для интеграции с AWS MediaConvert, Azure Media Services
- **Системы уведомлений**: Расширить `NotificationGateway` для поддержки email, Telegram, Discord
- **Мониторинг**: Добавить интеграцию с Application Insights, Prometheus

### 4.6. Добавление новых форматов

**Механизм**: Расширение через `ConversionSettings` и `FFmpegExecutor`

**Шаги**:
1. **Domain**: Добавить поддержку новых форматов в `ConversionSettings`
2. **Infrastructure**: Расширить `FFmpegExecutor` для работы с новыми кодеками
3. **Application**: Обновить валидацию и обработку новых форматов
4. **UI**: Добавить опции выбора в интерфейс