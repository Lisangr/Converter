# План рефакторинга Converter - Критические исправления

## ЭТАП 1: DI и жизненный цикл (Фундамент)

### 1.1 Переход на Host + IHostedService
**Цель**: Правильный жизненный цикл сервисов и автоматическое управление IHostedService

**Изменения**:
- [ ] Создать `HostingExtensions.cs` с настройкой Host
- [ ] Изменить `Program.cs` для использования `Host.CreateDefaultBuilder()`
- [ ] Зарегистрировать `FfmpegBootstrapService` как `IHostedService`
- [ ] Переместить инициализацию FFmpeg в `StartAsync`/`StopAsync`
- [ ] Убрать ручные вызовы `EnsureFfmpegAsync`

**Файлы**: `Program.cs`, `Infrastructure/Ffmpeg/FfmpegBootstrapService.cs`

### 1.2 Исправление Singleton-Disposable конфликта
**Цель**: MainPresenter и IQueueProcessor должны корректно освобождаться

**Изменения**:
- [ ] Изменить MainPresenter на IDisposable без уничтожения IQueueProcessor
- [ ] Перенести управление жизненным циклом в Host
- [ ] Добавить корректную деактивацию в Host.StopAsync

### 1.3 ServiceProvider lifecycle
**Цель**: Автоматическое освобождение контейнера

**Изменения**:
- [ ] Использовать `using` для ServiceProvider в Program.cs
- [ ] Или перенести в Host для автоматического управления

## ЭТАП 2: Единый поток данных UI ↔ Presenter

### 2.1 Удаление дублирующего UI
**Цель**: Убрать файлы, которые дублируют функциональность

**Изменения**:
- [ ] Удалить старые файлы: `filesPanel`, `_dragDropPanel`, `FileListItem`
- [ ] Оставить только DataGridView + QueueItemsBinding
- [ ] Удалить методы Form1: `AddFilesToList`, `ProbeFileAsync`, `LoadThumbnailAsync`

### 2.2 Исправление событий IMainView
**Цель**: Все события должны проходить через presenter

**Изменения**:
- [ ] Убрать `AddFilesRequested?.Invoke` из кнопки "Добавить"
- [ ] Убрать прямые добавления в `filesPanel`
- [ ] Связать все UI события через `AddFilesRequestedAsync`
- [ ] Связать drag&drop с `FilesDroppedAsync`

### 2.3 Async события вместо EventHandler
**Цель**: Убрать async void и правильная обработка ошибок

**Изменения**:
- [ ] Заменить все EventHandler на Func<Task>
- [ ] Убрать `MakeAsyncEventHandler` и `HandleViewEventAsync`
- [ ] Прямые async подписки в MainPresenter

## ЭТАП 3: Объединение двух очередей

### 3.1 Удаление дублирования IQueueRepository/IQueueStore
**Цель**: Единая очередь вместо двух независимых

**Изменения**:
- [ ] Удалить `ChannelQueueProcessor.cs` (проблемный)
- [ ] Оставить только `IQueueRepository` + `IQueueStore`
- [ ] Создать простой `QueueProcessor` на базе `ChannelQueueProcessor`
- [ ] Убрать `IQueueStore.TryReserveAsync` - заменить на простые операции

### 3.2 Исправление MainPresenter
**Цель**: Работа только с одной очередью

**Изменения**:
- [ ] Убрать дублирующие операции с очередью
- [ ] Использовать только `IQueueRepository` для всего
- [ ] Убрать конфликты между кэшем и хранилищем

## ЭТАП 4: Асинхронность и конкурентность

### 4.1 Исправление паузы в процессоре
**Цель**: Убрать блокировку потоков при паузе

**Изменения**:
- [ ] Заменить `_pauseLock.WaitAsync()` на корректную логику
- [ ] Добавить `Release()` в блоке finally
- [ ] Исправить логику continue без Release

### 4.2 Исправление CancellationToken
**Цель**: Возможность повторного запуска после отмены

**Изменения**:
- [ ] Создавать новый CancellationTokenSource для каждого запуска
- [ ] Убрать повторное использование отмененного токена

### 4.3 Channel operations
**Цель**: Надежная работа с каналами

**Изменения**:
- [ ] Заменить `TryWrite` на `await WriteAsync`
- [ ] Добавить обработку переполнения канала

## ЭТАП 5: Вынос бизнес-логики из UI

### 5.1 Создание FileService
**Цель**: Убрать файловые операции из Form1

**Изменения**:
- [ ] Создать `IFileService` с методами: `AddFiles`, `ProbeFile`, `LoadThumbnail`
- [ ] Перенести логику из Form1 в `FileService`
- [ ] Заменить вызовы в Form1 на делегирование

### 5.2 Создание ThemeService правильно
**Цель**: Убрать ThemeManager.Instance

**Изменения**:
- [ ] Сделать ThemeManager внедряемым через DI
- [ ] Убрать все ссылки на `ThemeManager.Instance`
- [ ] Перенести логику в ThemeService

### 5.3 Исправление ConversionUseCase
**Цель**: Реальная конвертация вместо имитации

**Изменения**:
- [ ] Заменить `Task.Delay` на реальный FFmpeg вызов
- [ ] Создать реальные выходные файлы
- [ ] Добавить корректную обработку ошибок

## ЭТАП 6: Правильный IDisposable

### 6.1 Program.cs cleanup
**Цель**: Корректное освобождение ресурсов

**Изменения**:
- [ ] Обернуть ServiceProvider в using
- [ ] Или перенести в Host для автоматического управления

### 6.2 Form1 disposal
**Цель**: Освобождение всех ресурсов

**Изменения**:
- [ ] Добавить `_notificationService?.Dispose()`
- [ ] Добавить `_shareService?.Dispose()`
- [ ] Добавить `_thumbnailProvider?.Dispose()`
- [ ] Отменять фоновые задачи при закрытии

### 6.3 Background tasks cancellation
**Цель**: Предотвращение утечек

**Изменения**:
- [ ] Отменять `_ = LoadThumbnailAsync(...)` при закрытии
- [ ] Отменять `_ = ProbeFileAsync(...)` при закрытии
- [ ] Использовать `_lifecycleCts` для всех фоновых задач

## ЭТАП 7: Объединение доменных моделей

### 7.1 Удаление дублирования
**Цель**: Единая модель QueueItem

**Изменения**:
- [ ] Удалить `Models/QueueItem.cs`
- [ ] Использовать только `src/Converter.Domain/Models/QueueItem`
- [ ] Обновить все ссылки в коде
- [ ] Маппинг через `QueueItemViewModel.FromModel()`

### 7.2 Обновление ссылок
**Цель**: Единообразие типов

**Изменения**:
- [ ] Заменить `Converter.Models.QueueItem` на `Converter.Domain.Models.QueueItem`
- [ ] Обновить `QueueItemViewModel.FromModel()`
- [ ] Проверить все using statements

## ЭТАП 8: Финальная проверка

### 8.1 Тестирование
**Цель**: Проверка работоспособности

**Изменения**:
- [ ] Запуск приложения без ошибок
- [ ] Добавление файлов через кнопку
- [ ] Drag&drop файлов
- [ ] Запуск конвертации
- [ ] Пауза/возобновление
- [ ] Отмена конвертации
- [ ] Удаление файлов из очереди

### 8.2 Код ревью
**Цель**: Соответствие архитектурным принципам

**Изменения**:
- [ ] Form1 < 500 строк
- [ ] Нет бизнес-логики в UI
- [ ] Единый источник данных
- [ ] Правильный DI
- [ ] Нет утечек памяти

---

## Порядок выполнения:
1. **ЭТАП 1** (DI) - критически важен, от него зависит все остальное
2. **ЭТАП 2** (Поток данных) - основа для остальных изменений
3. **ЭТАП 3** (Объединение очередей) - убирает основные конфликты
4. **ЭТАП 4** (Асинхронность) - стабилизирует работу
5. **ЭТАП 5** (Бизнес-логика) - улучшает архитектуру
6. **ЭТАП 6** (IDisposable) - предотвращает утечки
7. **ЭТАП 7** (Модели) - убирает дублирование
8. **ЭТАП 8** (Проверка) - финальное тестирование

**Время выполнения**: ~4-6 часов интенсивной работы
**Риск**: Высокий - много взаимосвязанных изменений
**Возможность отката**: Обязательно делать коммиты после каждого этапа