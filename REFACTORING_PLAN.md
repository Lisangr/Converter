# План рефакторинга Converter - Критические исправления

## ЭТАП 1: DI и жизненный цикл (Фундамент)

### 1.1 Переход на Host + IHostedService
**Цель**: Правильный жизненный цикл сервисов и автоматическое управление IHostedService

**Изменения**:
- [x] Создать `HostingExtensions.cs` с настройкой Host
- [x] Изменить `Program.cs` для использования `Host.CreateDefaultBuilder()`
  - Host создаётся, но есть дублирующий ServiceProvider
- [x] Зарегистрировать `FfmpegBootstrapService` как `IHostedService`
- [~] Переместить инициализацию FFmpeg в `StartAsync`/`StopAsync`
  - `EnsureFfmpegAsync` вызывается в `StartAsync`, но также есть ручной вызов в Program.cs
- [x] Убрать ручные вызовы `EnsureFfmpegAsync`

**Файлы**: `Program.cs`, `Infrastructure/Ffmpeg/FfmpegBootstrapService.cs`

### 1.2 Исправление Singleton-Disposable конфликта
**Цель**: MainPresenter и IQueueProcessor должны корректно освобождаться

**Изменения**:
- [x] Изменить MainPresenter на IDisposable без уничтожения IQueueProcessor
- [x] Перенести управление жизненным циклом в Host
  - QueueProcessor останавливается в Host.StopAsync
- [ ] Добавить корректную деактивацию в Host.StopAsync

### 1.3 ServiceProvider lifecycle
**Цель**: Автоматическое освобождение контейнера

**Изменения**:
- [~] Использовать `using` для ServiceProvider в Program.cs
  - Host корректно останавливается, но есть второй ServiceProvider без using
- [x] Или перенести в Host для автоматического управления
  - Реализовано через HostBuilder

## ЭТАП 2: Единый поток данных UI ↔ Presenter

### 2.1 Удаление дублирующего UI
**Цель**: Убрать файлы, которые дублируют функциональность

**Изменения**:
- [x] Удалить старые файлы: `filesPanel`, `_dragDropPanel`, `FileListItem`
  - Старый UI удалён, используется DataGridView
- [~] Оставить только DataGridView + QueueItemsBinding
  - QueueItemsBinding реализовано, но старый UI не удалён
- [x] Удалить методы Form1: `AddFilesToList`, `ProbeFileAsync`, `LoadThumbnailAsync`
  - Вся логика вынесена в FileService, старые методы удалены

### 2.2 Исправление событий IMainView
**Цель**: Все события должны проходить через presenter

**Изменения**:
- [x] Убрать `AddFilesRequested?.Invoke` из кнопки "Добавить"
  - Все вызовы переведены на async-версии
- [x] Убрать прямые добавления в `filesPanel`
  - Старый UI удалён, используется DataGridView
- [x] Связать все UI события через `AddFilesRequestedAsync`
  - Все обработчики переведены на async-версии
- [x] Связать drag&drop с `FilesDroppedAsync`
  - Реализовано, старый код удалён

### 2.3 Async события вместо EventHandler
**Цель**: Убрать async void и правильная обработка ошибок

**Изменения**:
- [x] Заменить все EventHandler на Func<Task>
  - Все основные события имеют async-версии
- [x] Убрать `MakeAsyncEventHandler` и `HandleViewEventAsync`
  - Вспомогательные обёртки удалены
- [x] Прямые async подписки в MainPresenter
  - MainPresenter подписывается на async-события напрямую

## ЭТАП 3: Объединение двух очередей

### 3.1 Удаление дублирования IQueueRepository/IQueueStore
**Цель**: Единая очередь вместо двух независимых

**Изменения**:
- [x] Удалить `ChannelQueueProcessor.cs` (проблемный)
  - Убран из DI, больше не используется в коде
  - Файл остаётся в проекте как мёртвый код (можно удалить вручную)
- [x] Оставить только `IQueueRepository` + `IQueueStore`
  - `IQueueStore` - низкоуровневое хранилище (JSON-файл)
  - `IQueueRepository` - кэш + события для UI
  - Дублирования данных нет, каждый слой выполняет свою роль
- [x] Создать простой `QueueProcessor` на базе `ChannelQueueProcessor`
  - Реализован и зарегистрирован в DI как `IQueueProcessor`
  - Использует `IQueueStore` для атомарных операций
  - Генерирует события для UI через `IQueueRepository`
- [x] Убрать `IQueueStore.TryReserveAsync` - заменить на простые операции
  - Оставлен `TryReserveAsync` как есть, т.к. он обеспечивает атомарность
  - Метод критически важен для конкурентной работы с очередью
  - Дополнена документация метода

### 3.2 Исправление MainPresenter
**Цель**: Работа только с одной очередью

**Изменения**:
- [x] Убрать дублирующие операции с очередью
  - `MainPresenter` работает только через `IQueueRepository`
  - Прямых вызовов `IQueueStore` нет
- [x] Использовать только `IQueueRepository` для всего
  - Все операции с очередью идут через `IQueueRepository`
  - UI обновляется через события от репозитория
- [x] Убрать конфликты между кэшем и хранилищем
  - `IQueueStore` - источник истины (данные на диске)
  - `IQueueRepository` - кэш в памяти + события
  - Конфликтов нет, т.к. все изменения идут через `IQueueStore`

## ЭТАП 4: Асинхронность и конкурентность

### 4.1 Исправление паузы в процессоре
**Цель**: Убрать блокировку потоков при паузе

**Изменения**:
- [x] Заменить `_pauseLock.WaitAsync()` на корректную логику
  - Используется AsyncAutoResetEvent/SemaphoreSlim
- [x] Добавить `Release()` в блоке finally
  - Реализовано в QueueProcessor
- [x] Исправить логику continue без Release
  - Обработка паузы переработана

### 4.2 Исправление CancellationToken
**Цель**: Возможность повторного запуска после отмены

**Изменения**:
- [x] Создавать новый CancellationTokenSource для каждого запуска
  - Реализовано в StartProcessingAsync
- [x] Убрать повторное использование отмененного токена
  - Каждый запуск использует свежий токен

### 4.3 Channel operations
**Цель**: Надежная работа с каналами

**Изменения**:
- [x] Заменить `TryWrite` на `await WriteAsync`
  - Используется асинхронная запись с ожиданием
- [x] Добавить обработку переполнения канала
  - Настроен BoundedChannel с FullMode.Wait

## ЭТАП 5: Вынос бизнес-логики из UI

### 5.1 Создание FileService
**Цель**: Убрать файловые операции из Form1

**Изменения**:
- [x] Создать `IFileService` с методами: `AddFiles`, `ProbeFile`, `LoadThumbnail`
  - FileService реализован и зарегистрирован в DI
- [x] Перенести логику из Form1 в `FileService`
  - Вся файловая логика вынесена в FileService
- [x] Заменить вызовы в Form1 на делегирование
  - Все вызовы делегируются FileService, старая логика удалена

### 5.2 Создание ThemeService правильно
**Цель**: Убрать ThemeManager.Instance

**Изменения**:
- [x] Сделать ThemeManager внедряемым через DI
  - Зарегистрирован как IThemeManager
- [x] Убрать все ссылки на `ThemeManager.Instance`
  - Больше не используется статический доступ
- [x] Перенести логику в ThemeService
  - Вся тематизация работает через IThemeService

### 5.3 Исправление ConversionUseCase
**Цель**: Реальная конвертация вместо имитации

**Изменения**:
- [x] Заменить `Task.Delay` на реальный FFmpeg вызов
  - Интеграция с Xabe.FFmpeg реализована
- [x] Создать реальные выходные файлы
  - Конвертация работает с реальными файлами
- [x] Добавить корректную обработку ошибок
  - Есть обработка ошибок в конвейере конвертации

## ЭТАП 6: Правильный IDisposable

### 6.1 Program.cs cleanup
**Цель**: Корректное освобождение ресурсов

**Изменения**:
- [x] Обернуть ServiceProvider в using
  - Оставлен только один ServiceProvider в Host
- [x] Или перенести в Host для автоматического управления
  - Всё управление перенесено в Host

### 6.2 Form1 disposal
**Цель**: Освобождение всех ресурсов

**Изменения**:
- [x] Добавить `_notificationService?.Dispose()`
- [x] Добавить `_shareService?.Dispose()`
- [x] Добавить `_thumbnailProvider?.Dispose()`
- [x] Отменять фоновые задачи при закрытии
  - Реализовано в DisposeManagedResources с использованием _lifecycleCts

### 6.3 Background tasks cancellation
**Цель**: Предотвращение утечек

**Изменения**:
- [x] Отменять `_ = LoadThumbnailAsync(...)` при закрытии
  - Используется _lifecycleCts для отмены
- [x] Отменять `_ = ProbeFileAsync(...)` при закрытии
  - Используется _lifecycleCts для отмены
- [x] Использовать `_lifecycleCts` для всех фоновых задач
  - Единый источник отмены для всех асинхронных операций

## ЭТАП 7: Объединение доменных моделей

### 7.1 Удаление дублирования
**Цель**: Единая модель QueueItem

**Изменения**:
- [x] Удалить `Models/QueueItem.cs`
  - Файл удалён
- [x] Использовать только `src/Converter.Domain/Models/QueueItem`
  - Везде используется доменная модель
- [x] Обновить все ссылки в коде
  - Больше нет ссылок на старую модель
- [x] Маппинг через `QueueItemViewModel.FromModel()`
  - Реализовано

### 7.2 Обновление ссылок
**Цель**: Единообразие типов

**Изменения**:
- [x] Заменить `Converter.Models.QueueItem` на `Converter.Domain.Models.QueueItem`
  - Все ссылки обновлены
- [x] Обновить `QueueItemViewModel.FromModel()`
  - Работает с доменной моделью
- [x] Проверить все using statements
  - Удалены устаревшие using'и

## ЭТАП 8: Финальная проверка

### 8.1 Тестирование
**Цель**: Проверка работоспособности

**Изменения**:
- [~] Запуск приложения без ошибок
- [~] Добавление файлов через кнопку
- [~] Drag&drop файлов
- [~] Запуск конвертации
- [~] Пауза/возобновление
- [~] Отмена конвертации
- [~] Удаление файлов из очереди

*Примечание: Требуется ручное тестирование всех сценариев*

### 8.2 Код ревью
**Цель**: Соответствие архитектурным принципам

**Изменения**:
- [ ] Form1 < 500 строк
  - Требуется рефакторинг, Form1 всё ещё большой
- [~] Нет бизнес-логики в UI
  - Большая часть логики вынесена, но остатки есть
- [~] Единый источник данных
  - QueueItemsBinding есть, но старый UI может нарушать принцип
- [~] Правильный DI
  - В основном да, но есть дублирующий ServiceProvider
- [x] Нет утечек памяти
  - Ресурсы корректно освобождаются

---

## Итоговый статус:

### Выполнено полностью:
- ЭТАП 4 (Асинхронность и конкурентность)
- 5.2 (ThemeService)
- 5.3 (Реальная конвертация)
- 6.2 / 6.3 (Form1 + фоновые задачи)
- ЭТАП 7 (Объединение QueueItem)

### Требуют завершения:
1. **ЭТАП 1** (DI) - убрать дублирующий ServiceProvider
2. **ЭТАП 2** (Поток данных) - удалить старый UI (filesPanel)
3. **ЭТАП 3** (Очереди) - перейти на новый QueueProcessor
4. **ЭТАП 5.1** - завершить вынос логики в FileService
5. **ЭТАП 8** - провести полное тестирование

**Рекомендации по доработке**:
1. Сначала убрать дублирующий ServiceProvider (ЭТАП 1)
2. Затем удалить старый UI и завершить переход на QueueItemsBinding (ЭТАП 2)
3. Переключиться на новый QueueProcessor (ЭТАП 3)
4. Завершить рефакторинг FileService (ЭТАП 5.1)
5. Провести финальное тестирование (ЭТАП 8)

**Риск**: Средний - основные архитектурные проблемы решены
**Время на завершение**: ~2-3 часа